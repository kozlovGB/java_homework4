package dz_sem5.java_homework4;

import java.util.*;
import java.util.logging.Logger;

public class DzEx3 {
    // Вспомогательная функция для возврата приоритета данного оператора.
    // Обратите внимание, что выше приоритет, ниже его значение
    public static int prec(char c) {
        // Умножение и деление
        if (c == '*' || c == '/') {
            return 3;
        }

        // Сложение и вычитание
        if (c == '+' || c == '-') {
            return 4;
        }

        // Bitwise AND
        if (c == '&') {
            return 8;
        }

        // Побитовое XOR (исключающее или)
        if (c == '^') {
            return 9;
        }

        // Побитовое ИЛИ (включающее или)
        if (c == '|') {
            return 10;
        }

        // добавить больше операторов, если нужно

        return Integer.MAX_VALUE;            // для открывающей скобки '('
    }

    // Вспомогательная функция для проверки, является ли данный токен операндом
    public static boolean isOperand(char c) {
        return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||
                (c >= '0' && c <= '9');
    }

    // Функция для преобразования инфиксного выражения в постфиксное выражение.
    // Эта функция ожидает корректное инфиксное выражение
    public static String infixToPostfix(String infix) {
        // базовый вариант
        if (infix == null || infix.length() == 0) {
            return infix;
        }

        // создаем пустой stack для хранения операторов
        Stack<Character> s = new Stack<>();

        // создаем строку для хранения постфиксного выражения
        String postfix = "";

        // обрабатываем инфиксное выражение слева направо
        for (char c : infix.toCharArray()) {
            // Случай 1. Если текущий токен является открывающей скобкой '(',
            // помещаем его в stack
            if (c == '(') {
                s.add(c);
            }
            // Случай 2. Если текущий токен является закрывающей скобкой ')'
            else if (c == ')') {
                // извлекать токены из stack до соответствующего открытия
                // скобка '(' удалена. Добавляем каждый оператор в конце
                // постфиксного выражения
                while (s.peek() != '(') {//peek() — возвращает верхний элемент стека, но не удаляет его из стека
                    postfix += s.pop();
                }
                s.pop();//pop() — удаляет верхний элемент из стека и возвращает его.
            }

            // Случай 3. Если текущий токен является операндом, добавляем его в конец
            // постфиксного выражения
            else if (isOperand(c)) {
                postfix += c;
            }

            // Случай 4. Если текущий токен является оператором
            else {
                // удаляем из stack операторы с более высоким или равным приоритетом
                // и добавляем их в конец постфиксного выражения
                while (!s.isEmpty() && prec(c) >= prec(s.peek())) {
                    postfix += s.pop();
                }

                // наконец, помещаем текущий оператор на вершину stack
                s.add(c);
            }
        }

        // добавляем все оставшиеся операторы в stack в конце
        // постфиксного выражения
        while (!s.isEmpty()) {
            postfix += s.pop();
        }

        // возвращаем постфиксное выражение
        return postfix;
    }

    public static void main(String[] args) {
        Logger logger = Logger.getAnonymousLogger();
        String infix = "A*(B*C+D*E)+F";

        String postfix = infixToPostfix(infix);
        logger.info(postfix);
    }
}
